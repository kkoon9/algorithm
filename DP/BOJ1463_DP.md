Baekjoon 1463
=============
1로 만들기  <https://www.acmicpc.net/problem/1463>
---------------
- - -
### 다이나믹 프로그래밍
- - -
## 함수 설명
- MakeOne : 1을 만들기 위해 필요한 연산 횟수를 구하는 함수 (하향식 풀이에 사용된다.)
- dp : 1을 만들기 위해 필요한 연산 횟수를 구하는 함수 (상향식 풀이에 사용된다.)
## 풀이 방법
- memo[1] ~ memo[N]을 구할 때 각 원소에 최적의 해를 넣어줌으로써 Optimal Substructure를 만족한다.
~~~cpp
memo[1] = 0; // 1
memo[2] = 1; // 2 – 1
memo[3] = 2; // 3 – 1 – 1 : memo[i - 1] + 1
(i % 3 == 0 && memo[i](2) > memo[i / 3](0) + 1)
memo[3] = 1; // 3 / 3 : memo[i / 3] +1
memo[4] = 2; // 4 - 1 / 3 : memo[i - 1] +1
memo[5] = 3; // 5 - 1 - 1 / 3 : memo[i - 1] + 1
memo[6] = 4; // 6 -1 -1 -1 / 3 : memo[i - 1] + 1
(i % 3 == 0 && memo[i](4) > memo[i / 3](1) + 1)
memo[6] = 2; // 6 / 3 - 1 : memo[i / 3] +1
memo[7] = 3; // 7 -1 / 3 - 1 : memo[i - 1] + 1
memo[8] = 4; // 8 -1 - 1 / 3 - 1 : memo[i - 1] + 1
(i % 2 == 0 && memo[i](4) > memo[i / 2](2) + 1)
memo[8] = 3; // 8 / 2 - 1 / 3 : memo[i / 2] + 1
memo[9] = 4; // 9 - 1 / 2 - 1 / 3 : memo[i - 1] + 1
(i % 3 == 0 && memo[i](4) > memo[i / 3](1) + 1)
memo[9] = 2; // 3 / 3 / 3 : memo[i / 3] +1
memo[10] = 3; // 10 - 1 / 3 / 3 : memo[i - 1] + 1
(i % 2 == 0 && memo[i](3) > memo[i / 2](3) + 1)
~~~
- default 값으로 memo[i-1] + 1을 넣어주고 2 or 3으로 나누어 떨어지는지 비교하여 연산 횟수가 더 작은 값을 찾아낸다.
## Top-Down 방식
- 입력값 n에서 1을 뺀 값, 2,3을 나눈 값을 다시 MakeOne 함수에 넣어서 memo를 채워나가며 정답을 찾아간다.
- 메모리 37016 KB, 시간 36 ms

## Bottom-up 방식
- 1에서부터 n까지 memo를 채워나가며 정답을 찾아간다.
- 메모리 5888 KB, 시간 4 ms
